//
// RouteStep.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
    import AnyCodable
#endif

public struct RouteStep: Codable, Hashable {
    public enum DrivingSide: String, Codable, CaseIterable {
        case _left = "left"
        case _right = "right"
    }

    /** The distance traveled by the route, in double meters. */
    public var distance: Double?
    /** The estimated travel time, in double number of seconds. */
    public var duration: Double?
    public var geometry: AnyCodable?
    public var weight: Double?
    public var name: String?
    public var ref: String?
    public var pronunciation: String?
    public var destinations: AnyCodable?
    public var exits: AnyCodable?
    public var mode: String?
    public var maneuver: StepManeuver?
    public var intersections: [Intersection]?
    public var rotaryName: String?
    public var rotaryPronunciation: String?
    public var drivingSide: DrivingSide?
    public var voiceInstructions: [VoiceInstruction]?
    public var bannerInstructions: [BannerInstruction]?

    public init(distance: Double? = nil, duration: Double? = nil, geometry: AnyCodable? = nil, weight: Double? = nil, name: String? = nil, ref: String? = nil, pronunciation: String? = nil, destinations: AnyCodable? = nil, exits: AnyCodable? = nil, mode: String? = nil, maneuver: StepManeuver? = nil, intersections: [Intersection]? = nil, rotaryName: String? = nil, rotaryPronunciation: String? = nil, drivingSide: DrivingSide? = nil, voiceInstructions: [VoiceInstruction]? = nil, bannerInstructions: [BannerInstruction]? = nil) {
        self.distance = distance
        self.duration = duration
        self.geometry = geometry
        self.weight = weight
        self.name = name
        self.ref = ref
        self.pronunciation = pronunciation
        self.destinations = destinations
        self.exits = exits
        self.mode = mode
        self.maneuver = maneuver
        self.intersections = intersections
        self.rotaryName = rotaryName
        self.rotaryPronunciation = rotaryPronunciation
        self.drivingSide = drivingSide
        self.voiceInstructions = voiceInstructions
        self.bannerInstructions = bannerInstructions
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case distance
        case duration
        case geometry
        case weight
        case name
        case ref
        case pronunciation
        case destinations
        case exits
        case mode
        case maneuver
        case intersections
        case rotaryName = "rotary_name"
        case rotaryPronunciation = "rotary_pronunciation"
        case drivingSide = "driving_side"
        case voiceInstructions
        case bannerInstructions
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(distance, forKey: .distance)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(geometry, forKey: .geometry)
        try container.encodeIfPresent(weight, forKey: .weight)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(ref, forKey: .ref)
        try container.encodeIfPresent(pronunciation, forKey: .pronunciation)
        try container.encodeIfPresent(destinations, forKey: .destinations)
        try container.encodeIfPresent(exits, forKey: .exits)
        try container.encodeIfPresent(mode, forKey: .mode)
        try container.encodeIfPresent(maneuver, forKey: .maneuver)
        try container.encodeIfPresent(intersections, forKey: .intersections)
        try container.encodeIfPresent(rotaryName, forKey: .rotaryName)
        try container.encodeIfPresent(rotaryPronunciation, forKey: .rotaryPronunciation)
        try container.encodeIfPresent(drivingSide, forKey: .drivingSide)
        try container.encodeIfPresent(voiceInstructions, forKey: .voiceInstructions)
        try container.encodeIfPresent(bannerInstructions, forKey: .bannerInstructions)
    }
}
